# -*- coding: utf-8 -*-
"""Capstone.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hgfuE5OGw9mSWqfdi0OQWur0dm9F3J1y
"""

import torch
import torchvision
from torchvision import transforms, utils
from torch.utils.data import DataLoader
from torch.utils.tensorboard import SummaryWriter
writer = SummaryWriter()
import torchvision.datasets as datasets
from torchvision.datasets import ImageFolder
import torch.nn.functional as F
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import Dataset
import os
from PIL import Image
import matplotlib.pyplot as plt
from torch.optim.lr_scheduler import StepLR
import numpy as np
from PIL import ImageFile
from datetime import datetime
import pandas as pd
import random 
from shutil import copyfile
import re
import albumentations as albu
from torchvision.transforms import ToTensor
from sklearn.metrics import roc_auc_score
from skimage.io import imread, imsave
import skimage
from IPython import get_ipython

from google.colab import drive
drive.mount('/content/drive/')

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/MyDrive/run

normalize = transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
train_transformer = transforms.Compose([
    transforms.Resize((224,224)),
    #transforms.RandomResizedCrop((224),scale=(0.5,1.0)),
    transforms.RandomHorizontalFlip(),
    transforms.ToTensor(),
    normalize
])

val_transformer = transforms.Compose([
    transforms.Resize((224,224)),
    #transforms.CenterCrop(224),
    transforms.ToTensor(),
    normalize
])

batchsize = 40
def read_txt(txt_path):
    with open(txt_path) as f:
        lines = f.readlines()
    txt_data = [line.strip() for line in lines]
    return txt_data

class MyocarditisCMRDataset(Dataset):
    def __init__(self, root_dir, txt_abnormal, txt_normal, transform=None):
        """
        Args:
            txt_path (string): Path to the txt file with annotations.
            root_dir (string): Directory with all the images.
            transform (callable, optional): Optional transform to be applied
                on a sample.
        File structure:
        - root_dir
            - Abnormal
                - img1.png
                - img2.png
                - ......
            - Normal
                - img1.png
                - img2.png
                - ......
        """
        self.root_dir = root_dir
        self.txt_path = [txt_abnormal,txt_normal]
        self.classes = ['Abnormal', 'Normal']
        self.num_cls = len(self.classes)
        self.img_list = []
        for c in range(self.num_cls):
            cls_list = [[os.path.join(self.root_dir,self.classes[c],item), c] for item in read_txt(self.txt_path[c])]
            self.img_list += cls_list
        self.transform = transform

    def __len__(self):
        return len(self.img_list)

    def __getitem__(self, idx):
        if torch.is_tensor(idx):
            idx = idx.tolist()

        img_path = self.img_list[idx][0]
        image = Image.open(img_path).convert('RGB')

        if self.transform:
            image = self.transform(image)
        sample = {'img': image,
                  'label': int(self.img_list[idx][1])}
        return sample

# label smoothing loss function
def reduce_loss(loss, reduction='mean'):
    return loss.mean() if reduction=='mean' else loss.sum() if reduction=='sum' else loss

def linear_combination(x, y, epsilon):
    return epsilon * x + (1 - epsilon) * y

class LabelSmoothingCrossEntropy(nn.Module):
    def __init__(self, epsilon:float=0.1, reduction='mean'):
        super().__init__()
        self.epsilon = epsilon
        self.reduction = reduction
    
    def forward(self, preds, target):
        n = preds.size()[-1]
        log_preds = F.log_softmax(preds, dim=-1)
        loss = reduce_loss(-log_preds.sum(dim=-1), self.reduction)
        nll = F.nll_loss(log_preds, target, reduction=self.reduction)
        return linear_combination(loss/n, nll, self.epsilon)

if __name__ == '__main__':
    trainset = MyocarditisCMRDataset(root_dir='data',
                              txt_abnormal='Abnormal_train.txt',
                              txt_normal='Normal_train.txt',
                              transform= train_transformer)
    valset = MyocarditisCMRDataset(root_dir='data',
                              txt_abnormal='Abnormal_val.txt',
                              txt_normal='Normal_val.txt',
                              transform= val_transformer)
    testset = MyocarditisCMRDataset(root_dir='data',
                              txt_abnormal='Abnormal_test.txt',
                              txt_normal='Normal_test.txt',
                              transform= val_transformer)
    print(trainset.__len__())
    print(valset.__len__())
    print(testset.__len__())

    train_loader = DataLoader(trainset, batch_size=batchsize, drop_last=False, shuffle=True)
    val_loader = DataLoader(valset, batch_size=batchsize, drop_last=False, shuffle=False)
    test_loader = DataLoader(testset, batch_size=batchsize, drop_last=False, shuffle=False)

l = [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1,
        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0]
print(l.count(0))
print(l.count(1))

alpha = None
device = 'cuda'
def train(optimizer, epoch):
    model.train()
    train_loss = 0
    train_correct = 0

    for batch_index, batch_samples in enumerate(train_loader): 
        # move data to device
        data, target = batch_samples['img'].to(device), batch_samples['label'].to(device)
        optimizer.zero_grad()
        output = model(data)
        # criteria = nn.CrossEntropyLoss()
        criteria = LabelSmoothingCrossEntropy()
        loss = criteria(output, target.long())
        train_loss += loss
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
        scheduler.step()
        pred = output.argmax(dim=1, keepdim=True)
        train_correct += pred.eq(target.long().view_as(pred)).sum().item()
        # Display progress and write to tensorboard
        if batch_index % bs == 0:
            print('Train Epoch: {} [{}/{} ({:.0f}%)]\tTrain Loss: {:.6f}'.format(
                epoch, batch_index, len(train_loader),
                100.0 * batch_index / len(train_loader), loss.item()/bs))
    average_loss = train_loss/len(train_loader.dataset)
    print('\nTrain set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\n'.format(
        average_loss, train_correct, len(train_loader.dataset),
        100.0 * train_correct / len(train_loader.dataset)))
    f = open('model_result/{}.txt'.format(modelname), 'a+')
    f.write('\nTrain set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)'.format(
        train_loss/len(train_loader.dataset), train_correct, len(train_loader.dataset),
        100.0 * train_correct / len(train_loader.dataset)))
    f.close()
    l_training_loss.append(train_loss/len(train_loader.dataset))
    l_training_accuracy.append(100.0 * train_correct / len(train_loader.dataset))
    # Write to tensorboard
    writer.add_scalar(tag='Training Loss', scalar_value=train_loss/len(train_loader.dataset), global_step=epoch)

def val(epoch):
    model.eval()
    test_loss = 0
    correct = 0
    results = []
    # criteria = nn.CrossEntropyLoss()
    criteria = LabelSmoothingCrossEntropy()
    # Don't update model
    with torch.no_grad():
        tpr_list = []
        fpr_list = []
        predlist=[]
        scorelist=[]
        targetlist=[]
        # Predict
        for batch_index, batch_samples in enumerate(val_loader):
            data, target = batch_samples['img'].to(device), batch_samples['label'].to(device)
            output = model(data)
            criteria = nn.CrossEntropyLoss()
            loss = criteria(output, target.long())
            test_loss += criteria(output, target.long())
            score = F.softmax(output, dim=1)
            pred = output.argmax(dim=1, keepdim=True)
            correct += pred.eq(target.long().view_as(pred)).sum().item()
            # Display progress and write to tensorboard
            if batch_index % bs == 0:
                print('Validation Epoch: {} [{}/{} ({:.0f}%)]\tValidation Loss: {:.6f}'.format(
                    epoch, batch_index, len(val_loader),
                    100.0 * batch_index / len(val_loader), loss.item()/ bs))
            targetcpu=target.long().cpu().numpy()
            predlist=np.append(predlist, pred.cpu().numpy())
            scorelist=np.append(scorelist, score.cpu().numpy()[:,1])
            targetlist=np.append(targetlist,targetcpu)
        average_loss = test_loss/len(val_loader.dataset)
        print('\nValidation set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\n'.format(
            average_loss, correct, len(val_loader.dataset),
            100.0 * correct / len(val_loader.dataset)))
        f = open('model_result/{}.txt'.format(modelname), 'a+')
        f.write('\nValidation set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\n'.format(
            average_loss, correct, len(val_loader.dataset),
            100.0 * correct / len(val_loader.dataset)))
        f.write('\n')
        f.close()
        l_validation_loss.append(average_loss)
        l_validation_accuracy.append(100.0 * correct / len(val_loader.dataset))
    # Write to tensorboard
    writer.add_scalar(tag='Validation Loss', scalar_value=average_loss, global_step=epoch)
    return targetlist, scorelist, predlist, average_loss

def test(epoch):
    model.load_state_dict(torch.load("model_backup/{}.pt".format(modelname)))
    model.eval()
    test_loss = 0
    correct = 0
    results = []
    criteria = nn.CrossEntropyLoss()
    # Don't update model
    with torch.no_grad():
        tpr_list = []
        fpr_list = []
        predlist=[]
        scorelist=[]
        targetlist=[]
       
        # Predict
        for batch_index, batch_samples in enumerate(test_loader):
            data, target = batch_samples['img'].to(device), batch_samples['label'].to(device)
            output = model(data)
            loss = criteria(output, target.long())
            test_loss += criteria(output, target.long())
            score = F.softmax(output, dim=1)
            pred = output.argmax(dim=1, keepdim=True)
            correct += pred.eq(target.long().view_as(pred)).sum().item()
            if batch_index % bs == 0:
                print('Testing Epoch: {} [{}/{} ({:.0f}%)]\tTesting Loss: {:.6f}'.format(
                    epoch, batch_index, len(test_loader),
                    100.0 * batch_index / len(test_loader), loss.item()/ bs))
            targetcpu=target.long().cpu().numpy()
            predlist=np.append(predlist, pred.cpu().numpy())
            scorelist=np.append(scorelist, score.cpu().numpy()[:,1])
            targetlist=np.append(targetlist,targetcpu)
        average_loss = test_loss/len(test_loader.dataset)
        print('\nTest set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\n'.format(
            average_loss, correct, len(test_loader.dataset),
            100.0 * correct / len(test_loader.dataset)))
    # Write to tensorboard
    writer.add_scalar(tag='Test Accuracy', scalar_value=100.0 * correct / len(test_loader.dataset), global_step=epoch)
    return targetlist, scorelist, predlist, average_loss

import torchvision.models as models
from torchvision.models import resnet18, ResNet18_Weights
model = models.resnet18(weights=ResNet18_Weights.DEFAULT).cuda()
modelname = 'ResNet18'

# train
bs = 10
votenum = 10
last_validation_loss = float("inf")
import warnings
warnings.filterwarnings('ignore')
l_training_loss = []
l_validation_loss = []
l_training_accuracy = []
l_validation_accuracy = []
# optimizer = optim.SGD(model.parameters(), lr=0.001, momentum = 0.9)
optimizer = optim.Adam(model.parameters(), lr=0.0001, weight_decay = 0.0005)
scheduler = optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max=10)
# scheduler = StepLR(optimizer, step_size=1)
total_epoch = 100

for epoch in range(1, total_epoch+1):
    train(optimizer, epoch)
    targetlist, scorelist, predlist, val_loss = val(epoch)
    if val_loss < last_validation_loss:
        last_validation_loss = val_loss
        best_epoch = epoch
        TP = ((predlist == 1) & (targetlist == 1)).sum()
        TN = ((predlist == 0) & (targetlist == 0)).sum()
        FN = ((predlist == 0) & (targetlist == 1)).sum()
        FP = ((predlist == 1) & (targetlist == 0)).sum()
        p = TP / (TP + FP)
        r = TP / (TP + FN)
        s = TN / (TN + FP)
        F1 = 2 * r * p / (r + p)
        acc = (TP + TN) / (TP + TN + FP + FN)
        AUC = roc_auc_score(targetlist, scorelist)
        torch.save(model.state_dict(), "model_backup/{}.pt".format(modelname)) 
f = open('model_result/{}.txt'.format(modelname), 'a+')
f.write('\n The best epoch is {}, average recall: {:.4f}, average precision: {:.4f}, average specificity: {:.4f}, average F1: {:.4f}, average accuracy: {:.4f}, average AUC: {:.4f}'.format(
best_epoch, r, p, s, F1, acc, AUC))
f.close()

l_training_loss_cpu = torch.tensor(l_training_loss, device = 'cpu').tolist()
l_validation_loss_cpu = torch.tensor(l_validation_loss, device = 'cpu').tolist()
l_training_accuracy_cpu = torch.tensor(l_training_accuracy, device = 'cpu').tolist()
l_validation_accuracy_cpu = torch.tensor(l_validation_accuracy, device = 'cpu').tolist()
df = {'training_loss': l_training_loss_cpu,
      'validation_loss': l_validation_loss_cpu,
      'training_accuracy': l_training_accuracy_cpu,
      'validation_accuracy': l_validation_accuracy_cpu}
df = pd.DataFrame(df,index=np.arange(1, total_epoch+1))
df.to_csv('model_result/loss_and_accuracy_lasmg.csv')

# test
bs = 10
import warnings
warnings.filterwarnings('ignore')

for epoch in range(1):    
    targetlist, scorelist, predlist, test_loss = test(epoch)
    TP = ((predlist == 1) & (targetlist == 1)).sum()
    TN = ((predlist == 0) & (targetlist == 0)).sum()
    FN = ((predlist == 0) & (targetlist == 1)).sum()
    FP = ((predlist == 1) & (targetlist == 0)).sum()
    p = TP / (TP + FP)
    r = TP / (TP + FN)
    s = TN / (TN + FP)
    F1 = 2 * r * p / (r + p)
    acc = (TP + TN) / (TP + TN + FP + FN)
    AUC = roc_auc_score(targetlist, scorelist)
    print('\n Testing average recall: {:.4f}, average precision: {:.4f}, average specificity: {:.4f},average F1: {:.4f}, average accuracy: {:.4f}, average AUC: {:.4f}'.format(
r, p, s, F1, acc, AUC))

f = open('model_result/test{}.txt'.format(modelname), 'a+')
f.write('\n Testing average recall: {:.4f}, average precision: {:.4f},a verage specificity: {:.4f},average F1: {:.4f}, average accuracy: {:.4f}, average AUC: {:.4f}'.format(
r, p, s, F1, acc, AUC))
f.close()