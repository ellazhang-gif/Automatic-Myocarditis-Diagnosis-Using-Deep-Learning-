# -*- coding: utf-8 -*-
"""Copy of Capstone_Contrastive_new.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-f5HdGdXK0MW-kvt7XSXlDkzd46xvJ6B
"""

import torch
import torchvision
from torchvision import transforms, utils
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
from torchvision.datasets import ImageFolder
import torch.nn.functional as F
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import Dataset
import os
from PIL import Image
import matplotlib.pyplot as plt
from torch.optim.lr_scheduler import StepLR
import numpy as np
from PIL import ImageFile
from datetime import datetime
import pandas as pd
import random 
from shutil import copyfile
import re
from torchvision.transforms import ToTensor
from sklearn.metrics import roc_auc_score
from skimage.io import imread, imsave
import skimage
from IPython import get_ipython
import argparse
import torch.backends.cudnn as cudnn
from torch.utils.tensorboard import SummaryWriter
torch.cuda.empty_cache()

# Commented out IPython magic to ensure Python compatibility.
from google.colab import drive
drive.mount('/content/drive/')
# %cd /content/drive/MyDrive/run
!cp /content/drive/MyDrive/run/networks/resnet_big.py /content
from networks.resnet_big import SupConResNet
!cp /content/drive/MyDrive/run/losses.py /content
from losses import SupConLoss
!cp /content/drive/MyDrive/run/util.py /content
from util import TwoCropTransform, AverageMeter

normalize = transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
train_transformer = transforms.Compose([
    transforms.Resize((224,224)),
    #transforms.RandomResizedCrop((224),scale=(0.5,1.0)),
    transforms.RandomHorizontalFlip(),
    transforms.ToTensor(),
    normalize
])

val_transformer = transforms.Compose([
    transforms.Resize((224,224)),
    #transforms.CenterCrop(224),
    transforms.ToTensor(),
    normalize
])

batchsize = 20
def read_txt(txt_path):
    with open(txt_path) as f:
        lines = f.readlines()
    txt_data = [line.strip() for line in lines]
    return txt_data

class MyocarditisCMRDataset(Dataset):
    def __init__(self, root_dir, txt_abnormal, txt_normal, transform=None):
        """
        Args:
            txt_path (string): Path to the txt file with annotations.
            root_dir (string): Directory with all the images.
            transform (callable, optional): Optional transform to be applied
                on a sample.
        File structure:
        - root_dir
            - Abnormal
                - img1.png
                - img2.png
                - ......
            - Normal
                - img1.png
                - img2.png
                - ......
        """
        self.root_dir = root_dir
        self.txt_path = [txt_abnormal,txt_normal]
        self.classes = ['Abnormal', 'Normal']
        self.num_cls = len(self.classes)
        self.img_list = []
        for c in range(self.num_cls):
            cls_list = [[os.path.join(self.root_dir,self.classes[c],item), c] for item in read_txt(self.txt_path[c])]
            self.img_list += cls_list
        self.transform = transform

    def __len__(self):
        return len(self.img_list)

    def __getitem__(self, idx):
        if torch.is_tensor(idx):
            idx = idx.tolist()

        img_path = self.img_list[idx][0]
        image = Image.open(img_path).convert('RGB')

        if self.transform:
            image = self.transform(image)
        sample = {'img': image,
                  'label': int(self.img_list[idx][1])}
        return sample

if __name__ == '__main__':
    trainset = MyocarditisCMRDataset(root_dir='data',
                              txt_abnormal='Abnormal_train.txt',
                              txt_normal='Normal_train.txt',
                              transform= TwoCropTransform(train_transformer))
    valset = MyocarditisCMRDataset(root_dir='data',
                              txt_abnormal='Abnormal_val.txt',
                              txt_normal='Normal_val.txt',
                              transform= val_transformer)
    testset = MyocarditisCMRDataset(root_dir='data',
                              txt_abnormal='Abnormal_test.txt',
                              txt_normal='Normal_test.txt',
                              transform= val_transformer)
    print(trainset.__len__())
    print(valset.__len__())
    print(testset.__len__())
    #print(trainset[1])
    #print(valset[1])
    train_loader = DataLoader(trainset, batch_size=batchsize, drop_last=False, shuffle=True)
    val_loader = DataLoader(valset, batch_size=batchsize, drop_last=False, shuffle=False)
    test_loader = DataLoader(testset, batch_size=batchsize, drop_last=False, shuffle=False)

def set_model():
    model = SupConResNet(name='resnet18')
    criterion = SupConLoss(temperature=0.07)

    # enable synchronized Batch Normalization
    # if opt.syncBN:
    #     model = apex.parallel.convert_syncbn_model(model)

    if torch.cuda.is_available():
        if torch.cuda.device_count() > 1:
            model.encoder = torch.nn.DataParallel(model.encoder)
        model = model.cuda()
        criterion = criterion.cuda()
        cudnn.benchmark = True

    return model, criterion

alpha = None
device = 'cuda'
def train(criterion, criterion_ce, optimizer, epoch):
    model.train()
    train_loss = 0
    for batch_index, batch_samples in enumerate(train_loader): 
        
        # move data to device
        data, target = batch_samples['img'], batch_samples['label']
        data = torch.cat([data[0], data[1]], dim=0)
        if torch.cuda.is_available():
          data = data.cuda(non_blocking=True)
          target = target.cuda(non_blocking=True)
        bsz = target.shape[0]
        
        # compute loss
        output, logit = model(data)
        f1, f2 = torch.split(output, [bsz, bsz], dim=0)
        l1, l2 = torch.split(logit, [bsz, bsz], dim=0)        
        output = torch.cat([f1.unsqueeze(1), f2.unsqueeze(1)], dim=1)
        logit = torch.cat([l1, l2], dim=1)       
        loss = 0.3*criterion(output, target.long())+criterion_ce(logit, target.long())
        train_loss += loss

        pred = logit.argmax(dim=1, keepdim=True)
        
        # Adam 
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
        scheduler.step()

        # Display progress and write to tensorboard
        if batch_index % bs == 0:
            print('Train Epoch: {} [{}/{} ({:.0f}%)]\tTrain Loss: {:.6f}'.format(
                epoch, batch_index, len(train_loader),
                100.0 * batch_index / len(train_loader), loss.item()/bsz))
    
    # write training loss to the tensorboard
    average_loss = train_loss/len(train_loader.dataset)
    writer.add_scalar('Training loss', average_loss, global_step=step)
  
    print('\nTrain set: Average loss: {:.4f}\n'.format(
        average_loss))
    f = open('model_result/contrastive_weight3.txt', 'a+')
    f.write('\nTrain set: Average loss: {:.4f}'.format(
        average_loss))
    f.close()
    l_training_loss.append(average_loss)

def val(criterion, criterion_ce, epoch):
    
    model.eval()
    test_loss = 0
    correct = 0
    results = []
    
    TP = 0
    TN = 0
    FN = 0
    FP = 0
    # Don't update model
    with torch.no_grad():
        tpr_list = []
        fpr_list = []
        
        predlist=[]
        scorelist=[]
        targetlist=[]
        # Predict
        for batch_index, batch_samples in enumerate(val_loader):
            data, target = batch_samples['img'], batch_samples['label']
            #data = torch.cat([data[0], data[0]], dim=0)
            
            if torch.cuda.is_available():
              data = data.cuda(non_blocking=True)
              target = target.cuda(non_blocking=True)
            bsz = target.shape[0]
        
            output, logit = model(data)
            
            #f1, f2 = torch.split(output, [bsz, bsz], dim=0)
            #l1, l2 = torch.split(logit, [bsz, bsz], dim=0)        
            output = torch.cat([output.unsqueeze(1), output.unsqueeze(1)], dim=1)
            logit = torch.cat([logit, logit], dim=1)
            
            loss = criterion_ce(logit, target.long())
            test_loss += loss
            score = F.softmax(logit, dim=1)
            pred = logit.argmax(dim=1, keepdim=True)
            #pred.size() is [20,1,512]
            #target.long().size() is torch.Size([20])
            correct += pred.eq(target.long().view_as(pred)).sum().item()
            

            # Display progress and write to tensorboard
            if batch_index % bs == 0:
                print('Validation Epoch: {} [{}/{} ({:.0f}%)]\tValidation Loss: {:.6f}'.format(
                    epoch, batch_index, len(val_loader),
                    100.0 * batch_index / len(val_loader), loss.item()/ bsz))
            

            targetcpu=target.long().cpu().numpy()
            predlist=np.append(predlist, pred.cpu().numpy())
            scorelist=np.append(scorelist, score.cpu().numpy()[:,1])
            targetlist=np.append(targetlist,targetcpu)

        # write validation loss and accuracy to the tensorboard
        average_loss = test_loss/len(val_loader.dataset)
        validation_accuracy = 100.0 * correct / len(val_loader.dataset)
        writer.add_scalar('Validation loss', average_loss, global_step=step)
        writer.add_scalar('Validation Accuracy', validation_accuracy, global_step=step)
        print('\nValidation set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\n'.format(
            average_loss, correct, len(val_loader.dataset),
            validation_accuracy))
        f = open('model_result/contrastive_weight3.txt', 'a+')
        f.write('\nValidation set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\n'.format(
            average_loss, correct, len(val_loader.dataset),
            validation_accuracy))
        f.write('\n')
        f.close()
    l_validation_loss.append(average_loss)
          
    return targetlist, scorelist, predlist, average_loss

def test(criterion, criterion_ce, epoch):
    model.load_state_dict(torch.load("model_backup/best_contrastive_weight3.pt"))
    model.eval()
    test_loss = 0
    correct = 0
    results = []
    TP = 0
    TN = 0
    FN = 0
    FP = 0
    # Don't update model
    with torch.no_grad():
        tpr_list = []
        fpr_list = []
        predlist=[]
        scorelist=[]
        targetlist=[]
        # Predict
        for batch_index, batch_samples in enumerate(test_loader):
            data, target = batch_samples['img'], batch_samples['label']
            if torch.cuda.is_available():
              data = data.cuda(non_blocking=True)
              target = target.cuda(non_blocking=True)
            bsz = target.shape[0]
            output, logit = model(data)     
            output = torch.cat([output.unsqueeze(1), output.unsqueeze(1)], dim=1)
            logit = torch.cat([logit, logit], dim=1)
            loss = criterion_ce(logit, target.long())
            test_loss += loss
            score = F.softmax(logit, dim=1)
            pred = logit.argmax(dim=1, keepdim=True)
            correct += pred.eq(target.long().view_as(pred)).sum().item()
            # Display progress and write to tensorboard
            if batch_index % bs == 0:
              print('Test Epoch: {} [{}/{} ({:.0f}%)]\tTest Loss: {:.6f}'.format(
                    epoch, batch_index, len(test_loader),
                    100.0 * batch_index / len(test_loader), loss.item()/ bsz))
            targetcpu=target.long().cpu().numpy()
            predlist=np.append(predlist, pred.cpu().numpy())
            scorelist=np.append(scorelist, score.cpu().numpy()[:,1])
            targetlist=np.append(targetlist,targetcpu)
        average_loss = test_loss/len(test_loader.dataset)
        print('\nTest set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\n'.format(
            average_loss, correct, len(test_loader.dataset),
            100.0 * correct / len(test_loader.dataset)))
        f = open('model_result/test_contrastive_weight3.txt', 'a+')
        f.write('\nTest set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\n'.format(
            average_loss, correct, len(test_loader.dataset),
            100.0 * correct / len(test_loader.dataset)))
        f.write('\n')
        f.close()
    return targetlist, scorelist, predlist, average_loss

# build model and criterion 
model, criterion = set_model()
criterion_ce = nn.CrossEntropyLoss(label_smoothing=0.1)

writer = SummaryWriter(f'runs/tryingout_tensorboard')

# train
bs = 10
votenum = 10
total_epoch = 100
last_validation_loss = float("inf")
import warnings

r_list = []
p_list = []
acc_list = []
AUC_list = []

vote_pred = np.zeros(valset.__len__())
vote_score = np.zeros(valset.__len__())

# build optimizer
optimizer = optim.Adam(model.parameters(), lr=0.0001, weight_decay = 0.0005)

# build scheduler
scheduler = optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max=10)


l_training_loss = []
l_validation_loss = []

# model.load_state_dict(torch.load("model_backup/best_contrastive.pt"))
step = 1
for epoch in range(1, total_epoch+1):
    train(criterion, criterion_ce, optimizer, epoch)
    targetlist, scorelist, predlist, val_loss = val(criterion, criterion_ce, epoch)
    step += 1
    if val_loss < last_validation_loss:
      last_validation_loss = val_loss
      best_epoch = epoch

      TP = ((predlist == 1) & (targetlist == 1)).sum()
      TN = ((predlist == 0) & (targetlist == 0)).sum()
      FN = ((predlist == 0) & (targetlist == 1)).sum()
      FP = ((predlist == 1) & (targetlist == 0)).sum()

      p = TP / (TP + FP)
      r = TP / (TP + FN)
      s = TN / (TN + FP)
      F1 = 2 * r * p / (r + p)
      acc = (TP + TN) / (TP + TN + FP + FN)
      AUC = roc_auc_score(targetlist, scorelist)
        
      torch.save(model.state_dict(), "model_backup/best_contrastive_weight3.pt") 
    
f = open('model_result/contrastive_weight3.txt', 'a+')
f.write('\n The best epoch is {}, average recall: {:.4f}, average precision: {:.4f}, average specificity: {:.4f}, average F1: {:.4f}, average accuracy: {:.4f}, average AUC: {:.4f}'.format(
best_epoch, r, p, s, F1, acc, AUC))
f.close()


    
# save the last model
torch.save(model.state_dict(), "model_backup/last.pt")

# Commented out IPython magic to ensure Python compatibility.
# %load_ext tensorboard
# %tensorboard --logdir runs

l_training_loss_cpu = torch.tensor(l_training_loss, device = 'cpu').tolist()
l_validation_loss_cpu = torch.tensor(l_validation_loss, device = 'cpu').tolist()
df = {'training_loss': l_training_loss_cpu,
      'validation_loss': l_validation_loss_cpu}
df = pd.DataFrame(df,index=np.arange(1, 18+1))
df.to_csv('model_result/loss_and_accuracy_con_weight3.csv')

# test
bs = 20
import warnings
warnings.filterwarnings('ignore')

vote_pred = np.zeros(testset.__len__())
vote_score = np.zeros(testset.__len__())

for epoch in range(1):    
    targetlist, scorelist, predlist, test_loss = test(criterion, criterion_ce, epoch)
    TP = ((predlist == 1) & (targetlist == 1)).sum()
    TN = ((predlist == 0) & (targetlist == 0)).sum()
    FN = ((predlist == 0) & (targetlist == 1)).sum()
    FP = ((predlist == 1) & (targetlist == 0)).sum()
    p = TP / (TP + FP)
    r = TP / (TP + FN)
    s = TN / (TN + FP)
    F1 = 2 * r * p / (r + p)
    acc = (TP + TN) / (TP + TN + FP + FN)
    AUC = roc_auc_score(targetlist, scorelist)

    vote_pred = np.zeros(testset.__len__())
    vote_score = np.zeros(testset.__len__())

    print('\n Testing average recall: {:.4f}, average precision: {:.4f}, average specificity: {:.4f},average F1: {:.4f}, average accuracy: {:.4f}, average AUC: {:.4f}'.format(
r, p, s, F1, acc, AUC))

f = open('model_result/test{}.txt'.format('contrastive'), 'a+')
f.write('\n Testing average recall: {:.4f}, average precision: {:.4f},average specificity: {:.4f},average F1: {:.4f}, average accuracy: {:.4f}, average AUC: {:.4f}'.format(
r, p, s, F1, acc, AUC))
f.close()